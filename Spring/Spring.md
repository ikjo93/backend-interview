#### Q. @SpirngBootApplication의 용도는?

<details>
<summary>답변 확인하기</summary>
  
```
스프링 부트의 자동 설정 기능(Bean 읽기 및 생성 등)

특히, @SpringBootApplication이 있는 위치부터 설정을 읽어가기 때문에 이 애노테이션이 붙은 클래스는 항상 프로젝트의 최상단에 위치해야 함
```
  
</details>

#### Q. 스프링 부트 프로젝트 main 메서드에서 실행하는 SpringApplication.run의 역할은?

<details>
<summary>답변 확인하기</summary>
  
```
내장 WAS 실행
```
  
</details>

#### Q. 내장 WAS란?

<details>
<summary>답변 확인하기</summary>
  
```
별도로 외부에 WAS를 두지 않고 애플리케이션을 실행할 때 내부에서 WAS를 실행하는 것
이로 인해 서버에 톰캣을 설치할 필요가 없고 스프링 부트로 만들어진 Jar 파일만 실행하면 됨
```
  
</details>

#### Q. 내장 WAS를 사용하는 이유?

<details>
<summary>답변 확인하기</summary>
  
```
언제 어디서나 같은 환경에서 스프링 부트를 배포할 수 있기 때문
외장 WAS를 쓴다면 모든 서버는 WAS의 종류와 버전, 설정을 일치시켜야 하는 번거로움 존재
```
  
</details>

#### Q. 서비스 계층의 역할은?

<details>
<summary>답변 확인하기</summary>
  
```
트랜잭션의 범위를 지정하고 도메인 간의 순서를 보장하도록 함
이때 비지니스 로직 처리는 도메인에서 담당하며 서비스에서 비지니스 로직을 처리하는 방식을 트랜잭션 스크립트라고 함
```
  
</details>

#### Q. 스프링에서 Bean을 주입(DI) 방식별 차이 설명

<details>
<summary>답변 확인하기</summary>
  
```
1. 생성자 주입 방식

스프링 빈 생성 단계에서 의존성이 주입됨

순환 참조는 생성자 주입에서만 문제가 된다. 객체 생성 시점에 빈을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 그 빈을 참조하기 때문에 오류가 발생한다.
순환 참조가 있는 객체 설계는 잘못된 설계이다. 생성자 주입을 사용하여 순환 참조되는 설계를 사전에 막을 수 있다.

아울러 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.
오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.(불변해야 한다.)
이때 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

또한 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있어 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.

※ 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.

스프링 프레임워크에서 역시 생성자 주입을 적극 지원하고 있기 때문에 생성자가 1개만 있을 경우에는 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공
  
또한, 순수 자바 클래스 로직 테스트 시에도 생성자 주입을 사용하면 다형성이 발휘되어 다양한 테스트가 가능해진다.

2. 필드 주입 방식

스프링 빈 생성 이후에 필드에 대해 의존관계 주입이 일어남

필드에 @Autowired을 추가한 의존성 주입방식으로,
순환 참조가 일어날 우려도 있고 이로 인해 스택오버플로우 등의 에러가 발생할 우려가 있다.

3. 수정자(setter) 주입 방식)

스프링 빈 생성 이후에 수정자를 호출하여 의존관계 주입이 일어남

중간에 의존성이 변경될 우려가 있다.

수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다. 누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.

다만, 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여함으로써 생성자 주입과 수정자 주입을 동시에 사용할 수는 있다.
  
※ 참고자료 : https://madplay.github.io/post/why-constructor-injection-is-better-than-field-injection
```
  
</details>

#### Q. Dto 클래스와 Entity 클래스를 분리하는 이유는?

<details>
<summary>답변 확인하기</summary>
  
```
클라이언트와 맞닿아 있는 데이터는 수정이 빈번한데,
이러한 수정으로 인해 테이블과 연결된 데이터를 수정하게 되며 비지니스 로직 등에 큰 영향을 미치게 되기 때문에 분리하는 것이 좋음
아울러 데이터를 응답해줄 때는 여러 테이블을 조인하는 경우가 많기 떄문에 하나의 Entity 클래스만으로 표현하기 어렵기도 함
```
  
</details>

#### Q. View Resolver란 무엇인가?

<details>
<summary>답변 확인하기</summary>
  
```
URL 요청의 결과를 전달할 타입과 값을 지정하는 관리자 
```
  
</details>

#### Q. 스프링 부트의 기본 절대경로(/) 값은?

<details>
<summary>답변 확인하기</summary>
  
```
src/main/resources/static
```
  
</details>

#### Q. 싱글톤 패턴의 장점과 문제점은?

<details>
<summary>답변 확인하기</summary>
  
```
장점

하나의 객체를 만들어 놓고 다른 클라이언트들이 이를 공유해서 사용하므로 매번 인스턴스를 생성할 필요가 없어 효율적이다.
  
주로 데이터베이스 연결 모듈에 많이 사용되며, 스프링 컨테이너 역시 객체를 싱글톤으로 관리한다.(싱글톤 컨테이너 역할 수행, 싱글톤 레지스트리 기능)

문제점
  
1. 소소한 문제로 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  
2. 의존 관계상 클라이언트가 구체 클래스에 의존함으로써 DIP와 OCP 원칙을 위반할 가능성이 높다.
  
3. 단위 테스트 시 서로 독립적인 객체를 사용해야하는데, 하나의 객체를 공유하기 때문에 단위 테스트가 어렵다.
  
```
  
</details>











